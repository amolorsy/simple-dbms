  options  {    static = true;    DEBUG_PARSER = false;  }  PARSER_BEGIN(SimpleDBMSParser)  import java.util.ArrayList;  public class SimpleDBMSParser  {    public static final int PRINT_SYNTAX_ERROR = 0;    public static final int PRINT_CREATE_TABLE = 1;    public static final int PRINT_DROP_TABLE = 2;    public static final int PRINT_DESC = 3;    public static final int PRINT_SHOW_TABLES = 4;    public static final int PRINT_INSERT = 5;    public static final int PRINT_DELETE = 6;    public static final int PRINT_SELECT = 7;    private static Record record;    	    public static void main(String args[]) throws ParseException    {      SimpleDBMSParser parser = new SimpleDBMSParser(System.in);      record = new Record();      record.setup();      while (true)      {        try        {          System.out.print("DB_2013-11379> ");          parser.command();        }        catch (Exception e)        {          // e.printStackTrace();          // printMessage(PRINT_SYNTAX_ERROR);          SimpleDBMSParser.ReInit(System.in);        }      }    }    /* public static void printMessage(int q)    {      switch (q)      {        case PRINT_SYNTAX_ERROR:          System.out.println("Syntax error");          break;        case PRINT_CREATE_TABLE:          System.out.println("\'CREATE TABLE\' requested");          break;        case PRINT_DROP_TABLE:          System.out.println("\'DROP TABLE\' requested");          break;        case PRINT_DESC:          System.out.println("\'DESC\' requested");          break;        case PRINT_SHOW_TABLES:          System.out.println("\'SHOW TABLES\' requested");          break;        case PRINT_INSERT:          System.out.println("\'INSERT\' requested");          break;        case PRINT_DELETE:          System.out.println("\'DELETE\' requested");          break;        case PRINT_SELECT:          System.out.println("\'SELECT\' requested");          break;      }    } */  }  PARSER_END(SimpleDBMSParser)  SKIP : { " " | "\r" | "\t" | "\n" }  TOKEN : /* Keywords */  {    < EXIT : "exit" >  | < INT : "int" >  | < CHAR : "char" >  | < DATE : "date" >  | < CREATE_TABLE : "create table" >  | < DROP_TABLE : "drop table" >  | < DESC : "desc" >  | < SHOW_TABLES : "show tables" >  | < INSERT_INTO : "insert into" >  | < DELETE_FROM : "delete from" >  | < SELECT : "select" >  | < PRIMARY_KEY : "primary key" >  | < FOREIGN_KEY : "foreign key" >  | < REFERENCES : "references" >  | < AS : "as" >  | < IS : "is" >  | < NULL : "null" >  | < NOT : "not" >  | < NOT_NULL : "not null" >  | < WHERE : "where" >  | < FROM : "from" >  | < VALUES : "values" >  | < AND : "and" >  | < OR : "or" >  }  TOKEN :  {    < SEMICOLON : ";" >  | < LEFT_PAREN : "(" >  | < RIGHT_PAREN : ")" >  | < STAR : "*" >  | < QUOTE : "'" >  | < UNDERSCORE : "_" >  | < COMMA : "," >  | < PERIOD : "." >  | < SIGN : "+" | "-" >  | < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >  | < DIGIT : [ "0"-"9" ] >  | < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >  | < NN : < DIGIT > < DIGIT > >  | < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >  | < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >  | < ALPHABET : [ "A"-"Z", "a"-"z" ] >  | < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >  | < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >  | < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET >                          | < NON_QUOTE_SPECIAL_CHARACTERS > | " " >  | < NON_QUOTE_SPECIAL_CHARACTERS : [ "`", "~", "!", "@", "#", "$", "%", "^",                                       "&", "*", "(", ")", "-", "_", "+", "=",                                       "\\", "|", ",", ".", "/", "?", "<", ">",                                       "{", "}", ";", ":", "[", "]" ] >  }  void command() :  {}  {    queryList()  | (      < EXIT >      < SEMICOLON >      {        record.quit();        System.exit(0);      }    )  }  void queryList() :  {    int q;  }  {    (      q = query()      < SEMICOLON >      {        System.out.print("DB_2013-11379> ");        // printMessage(q);      }    )+  }  int query() :  {}  {    (      createTableQuery()      {        return PRINT_CREATE_TABLE;      }    )  | (      dropTableQuery()      {        return PRINT_DROP_TABLE;      }    )  | (      descQuery()      {        return PRINT_DESC;      }    )  | (      showTablesQuery()      {        return PRINT_SHOW_TABLES;      }    )  | (      insertQuery()      {        return PRINT_INSERT;      }    )  | (      deleteQuery()      {        return PRINT_DELETE;      }    )  | (      selectQuery()      {        return PRINT_SELECT;      }    )  }  void createTableQuery() :  {    String tableName;    Table table;  }  {    < CREATE_TABLE >    tableName = tableName()    {      if (record.isTableExist(tableName))      {        Message.print(Message.TABLE_EXISTENCE_ERROR, null);        throw new ParseException();      }      table = new Table(record);      table.setTableName(tableName);    }    tableElementList(table)    {      record.save(table);      Message.print(Message.CREATE_TABLE_SUCCESS, tableName);    }  }  void dropTableQuery() :  {    ArrayList<String> tableNameList;  }  {    < DROP_TABLE >    tableNameList = tableNameList()    {      if (tableNameList.size() == 1 && tableNameList.get(0).equals("*"))      {        record.dropAllTables();        Message.print(Message.DROP_SUCCESS_ALL_TABLES, null);      }      else      {        for (String tableName : tableNameList)        {          if (!record.isTableExist(tableName))          {            Message.print(Message.NO_SUCH_TABLE, null);          }          else if (record.getTableDictionary().get(tableName).getReferencingTable() != null)          {            Message.print(Message.DROP_REFERENCED_TABLE_ERROR, tableName);          }          else          {            record.dropTable(tableName);            Message.print(Message.DROP_SUCCESS, tableName);          }        }      }    }  }  void descQuery() :  {}  {    < DESC >    tableNameList()  }  void showTablesQuery() :  {}  {    < SHOW_TABLES >  }  void insertQuery() :  {}  {    < INSERT_INTO >    tableName()    insertColumnsAndSource()  }  void deleteQuery() :  {}  {    < DELETE_FROM >    tableName()    (      whereClause()    )?  }  void selectQuery() :  {}  {    < SELECT >    selectList()    tableExpression()  }  void selectList() :  {}  {    < STAR >  | (      selectedColumn()      (        < COMMA >        selectedColumn()      )*    )  }  void selectedColumn() :  {}  {    (      (        LOOKAHEAD(2)        tableName()        < PERIOD >      )?      columnName()    )    (      < AS >      columnName()    )?  }  void tableExpression() :  {}  {    fromClause()    (      whereClause()    )?  }  void fromClause() :  {}  {    < FROM >    tableReferenceList()  }  void tableReferenceList() :  {}  {    referedTable()    (      < COMMA >      referedTable()    )*  }  String referedTable() :  {    String tableName;  }  {    tableName = tableName()    (      < AS >      tableName = tableName()      {        return tableName;      }    )?    {      return tableName;    }  }  void whereClause() :  {}  {    < WHERE >    booleanValueExpression()  }  /*    In this function, I resolved left-recursion problem by modifying function    booleanValueExpression() : booleanTerm() | (booleanValueExpression() < OR > booleanTerm())    to    booleanValueExpression() : booleanTerm() (< OR > booleanTerm())?.  */  void booleanValueExpression() :  {}  {    booleanTerm()    (      < OR >      booleanTerm()    )*  }  /*    In this function, I resolved left-recursion problem by modifying function    booleanTerm() : booleanFactor() | booleanTerm() < AND > booleanFactor()    to    booleanTerm() : booleanFactor() (< AND > booleanFactor())?.  */  void booleanTerm() :  {}  {    booleanFactor()    (      < AND >      booleanFactor()    )*  }  void booleanFactor() :  {}  {    (      < NOT >    )?    booleanTest()  }  void booleanTest() :  {}  {    predicate()  | parenthesizedBooleanExpression()  }  void parenthesizedBooleanExpression() :  {}  {    < LEFT_PAREN >    booleanValueExpression()    < RIGHT_PAREN >  }  /* In this function, I resolved javaCC lookahead problem by inserting LOOKAHEAD keyword */  void predicate() :  {}  {    LOOKAHEAD(4)    comparisonPredicate()  | nullPredicate()  }  void comparisonPredicate() :  {}  {    compOperand()    < COMP_OP >    compOperand()  }  /* In this function, I resolved javaCC lookahead problem by inserting LOOKAHEAD keyword */  void nullPredicate() :  {}  {    (      LOOKAHEAD(2)      tableName()      < PERIOD >    )?    columnName()    nullOperation()  }  /* In this function, I resolved javaCC lookahead problem by inserting LOOKAHEAD keyword */  void compOperand() :  {}  {    comparableValue()  | (      (         LOOKAHEAD(2)        tableName()        < PERIOD >      )?      columnName()    )  }  void nullOperation() :  {}  {    < IS >    (      < NOT_NULL >    | < NULL >    )  }  void insertColumnsAndSource() :  {}  {    (      columnNameList()    )?    valueList()  }  void valueList() :  {}  {    < VALUES >    < LEFT_PAREN >    value()    (      < COMMA >      value()    )*    < RIGHT_PAREN >  }  void value() :  {}  {    < NULL >  | comparableValue()  }  void comparableValue() :  {}  {    < INT_VALUE >  | < CHAR_STRING >  | < DATE_VALUE >  }  void tableElementList(Table table) :  {}  {    < LEFT_PAREN >    tableElement(table)    (      < COMMA >      tableElement(table)    )*    < RIGHT_PAREN >  }  /* Table element definition */  void tableElement(Table table) :  {}  {    columnDefinition(table)  | tableConstraintDefinition(table)  }  /* end */  /* Table column */  void columnDefinition(Table table) :  {    Column column = new Column();    String columnName;    ColumnType columnType;  }  {    columnName = columnName()    {      column.setColumnName(columnName);    }    columnType = dataType()    {      column.setColumnType(columnType);    }    (      < NOT_NULL >      {        column.guaranteeNotNull();      }    )?    {      table.addColumn(column);    }  }  /* end */  /* Primary key & Foreign Key */  void tableConstraintDefinition(Table table) :  {}  {    primaryKeyConstraint(table)  | referentialConstraint(table)  }  void primaryKeyConstraint(Table table) :  {    ArrayList<String> columnNameList;  }  {    < PRIMARY_KEY >    columnNameList = columnNameList()    {  	  table.setPrimaryKey(columnNameList);  	}    }  void referentialConstraint(Table table) :  {    ArrayList<String> columnNameList;    String referencingTableName;    ArrayList<String> referencingColumnNameList;  }  {    < FOREIGN_KEY >    columnNameList = columnNameList()    < REFERENCES >    referencingTableName = tableName()    referencingColumnNameList = columnNameList()    {      table.setForeignKey(columnNameList, referencingTableName, referencingColumnNameList);    }  }  /* end */    ArrayList<String> columnNameList() :  {    String columnName;    ArrayList<String> columnNameList = new ArrayList<String>();  }  {    < LEFT_PAREN >    columnName = columnName()    {      columnNameList.add(columnName);    }    (      < COMMA >      columnName = columnName()      {        columnNameList.add(columnName);      }    )*    < RIGHT_PAREN >    {      return columnNameList;    }  }  ArrayList<String> tableNameList() :  {    String tableName;    ArrayList<String> tableNameList;  }  {    < STAR >    {      tableNameList = new ArrayList<String>();      tableNameList.add("*");         return tableNameList;    }  | {      tableNameList = new ArrayList<String>();    }    (      tableName = tableName()      {        tableNameList.add(tableName);      }      (        < COMMA >        tableName = tableName()        {          tableNameList.add(tableName);        }      )*      {        return tableNameList;      }    )  }  String tableName() :  {    String tableName;  }  {    < LEGAL_IDENTIFIER >    {      Token token = getToken(0);      tableName = token.image;      return tableName;    }  }  String columnName() :  {    String columnName;  }  {    < LEGAL_IDENTIFIER >    {      Token token = getToken(0);      columnName = token.image;      return columnName;    }  }  /* Column type */  ColumnType dataType() :  {}  {    < INT >    {      Int intType = new Int();      return intType;    }  |    {      int value;    }    (      < CHAR >      < LEFT_PAREN >      < INT_VALUE >      {        Token token = getToken(0);        value = Integer.parseInt(token.image);      }      < RIGHT_PAREN >    )    {      if (value < 1)      {        Message.print(Message.CHAR_LENGTH_ERROR, null);        throw new ParseException();      }            Char charType = new Char();      charType.setSize(value);      return charType;    }  | < DATE >    {      Date dateType = new Date();      return dateType;    }  }  /* end */